# 浅谈二级指针的应用和指针引用



## 一. 二级指针的应用

### 记住这个规则：

- 如果你只需要**读取**或**修改指针指向的内容**，用一级指针

- 如果你需要**改变指针本身**（让它指向新的地方），用二级指针（C）或指针引用（C++）



### 示例：**创建二叉树为什么需要二级指针**

#### 1. **问题的核心**

创建二叉树时，**根节点可能为空**，我们需要**在函数内部修改外部指针变量**，让它指向新创建的节点。**因此需要使用二级指针/指针引用

**如果使用一级指针：**

```c
// C语言中典型的节点结构
typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 方法1：错误的一级指针版本
void createTreeWrong(TreeNode* root, int value) {
    if (root == NULL) {
        // 这里分配的节点无法传递出去！ 因为这个函数只是修改root的副本，类似于“按值传递”
        root = (TreeNode*)malloc(sizeof(TreeNode));
        root->data = value;
        root->left = NULL;
        root->right = NULL;
    }
}

int main() {
    TreeNode* root = NULL;  // 空树
    createTreeWrong(root, 10);
    
    // root仍然是NULL！因为函数修改的是root的副本
    // 我们无法获得新创建的节点
    return 0;
}
```

**正确方法：使用二级指针**

```c
// 正确的方法：使用二级指针
void createTree(TreeNode** root, int value) {
    if (*root == NULL) {
        // *root解引用得到实际的指针变量
        *root = (TreeNode*)malloc(sizeof(TreeNode));
        (*root)->data = value;
        (*root)->left = NULL;
        (*root)->right = NULL;
    }
}

int main() {
    TreeNode* root = NULL;
    
    // 传递指针的地址
    createTree(&root, 10);
    
    // 现在root指向新创建的节点
    printf("%d\n", root->data);  // 输出10
    
    // 继续添加节点
    createTree(&(root->left), 5);
    createTree(&(root->right), 15);
    
    return 0;
}
```



#### 2.辨析：**使用一级指针修改二叉树结点的内容是完全正确的！**

```c
// 使用一级指针修改结点的内容 - 完全正确！
void modifyNodeData(TreeNode* node, int newValue) {
    if (node != NULL) {
        node->data = newValue;  // ✅ 正确！修改指针指向的内容
    }
}

void modifyChildPointers(TreeNode* node) {
    if (node != NULL) {
        // 修改左子节点的data
        if (node->left != NULL) {
            node->left->data = 100;  // ✅ 正确！
        }
        
        // 修改右子节点的指针指向
        if (node->right != NULL) {
            // 修改right指针指向的内容，但right指针本身不变
            node->right->data = 200;  // ✅ 正确！
        }
    }
}

int main() {
    TreeNode* root = malloc(sizeof(TreeNode));
    root->data = 10;
    root->left = malloc(sizeof(TreeNode));
    root->left->data = 5;
    
    modifyNodeData(root, 20);  // root现在包含data=20
    modifyNodeData(root->left, 15);  // 左子节点的data=15
    
    // 所有修改都成功了！
    return 0;
}
```



#### 3.理解指针的层次

```c
// 一级指针：可以修改指向的内容
TreeNode* node;
node->data = 10;    // ✅ 可以
node->left = ...;   // ✅ 可以

// 但无法修改指针变量本身（让它指向其他地方）
void func(TreeNode* p) {
    p = malloc(...);  // ❌ 只修改了局部副本
}

// 二级指针：可以修改指针本身
void func2(TreeNode** pp) {
    *pp = malloc(...);  // ✅ 可以修改原指针
}
```



#### 4.简单判断方法

问自己：**我需要改变的是指针变量本身(只能通过二级指针完成)，还是它指向的内存(一级指针便可以完成)？**

```c
TreeNode* ptr = NULL;

// 情况1：我想让ptr指向一个新节点
// 需要修改ptr本身 → 需要二级指针

// 情况2：ptr已经指向一个节点，我想修改这个节点的数据
// 修改ptr指向的内容 → 一级指针就够了

// 情况3：ptr指向一个节点，我想让它的left指向新节点
// 修改ptr->left → 一级指针就够了（因为ptr->left只是ptr指向的结构体中的一个成员）
```



#### 5.结论

- **修改二叉树结点的内容（值、子指针等）**：一级指针完全正确✅
- **让一个指针变量指向新节点**：需要二级指针✅
- **创建初始为空的树**：需要二级指针✅
- **在已有树上操作**：一级指针通常就够了✅
- **注：二级指针能做一切一级指针能做的，只不过对于具体情况来讲，使用一级指针更加方便**



## 二. 是否有其他方法能够做到与使用二级指针一样的效果但更加方便

### 以二叉搜索树插入为例

#### 方法一： 返回新指针

```cpp
TreeNode* insertBST(TreeNode* root, int value) {
    if (root == NULL) {
        TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
        newNode->data = value;
        newNode->left = newNode->right = NULL;
        return newNode;
    }
    
    if (value < root->data) {
        root->left = insertBST(root->left, value);
    } else if (value > root->data) {
        root->right = insertBST(root->right, value);
    }
    
    return root;
}

// 使用
int main() {
    TreeNode* root = NULL;
    root = insertBST(root, 10);
    root = insertBST(root, 5);
    root = insertBST(root, 15);
}
```



#### 方法二：使用指针引用(C++)

##### 指针引用介绍：

**1.什么是指针引用**

指针引用就是**对指针的引用**。可以这样理解：

```cpp
int x = 10;
int* ptr = &x;      // ptr是指向x的指针
int*& ref = ptr;    // ref是ptr的引用（指针的别名）
```

这里 `ref` 不是指向 `ptr` 的新指针，而是 `ptr` 的另一个名字。

**2.基本概念对比**

|      类型      |   声明    |        作用        |
| :------------: | :-------: | :----------------: |
|      指针      |  Node* p  |   存储地址的变量   |
|   指针的引用   | Node*& r  |   指针变量的别名   |
| 指向指针的指针 | Node** pp | 存储指针地址的指针 |

**3.理解引用和指针的区别**

```cpp
int a = 10;
int b = 20;

int* p = &a;    // p是指向a的指针
int*& r = p;    // r是p的引用

// 情况1：
p = &b;         // p现在指向b
cout << *r << endl;  // 输出20，因为r是p的别名

// 情况2：
*r = 30;        // 这修改的是p指向的值（即b的值）
cout << b << endl;  // 输出30

// 情况3：
int c = 40;
r = &c;         // 这修改的是p本身，让p指向c
cout << *p << endl;  // 输出40
```

**关键点**：通过指针引用，你既可以修改指针本身，也可以修改指针指向的值。



**4.从右向左读声明**

```cpp
Node*& ref;  // 从右向左：ref是一个引用，引用的是Node*（指针）
```

**5.与二级指针对比**

```cpp
void func1(Node** pp);  // 调用：func1(&head);
void func2(Node*& p);   // 调用：func2(head);
```

**6.使用场景（重要）**

- 当函数需要**修改指针本身**（而不仅仅是指针指向的内容）
- 当你想让函数能**修改调用者的指针变量**
- 当二级指针语法太复杂时，用指针引用简化



#### 使用指针引用完成二叉搜索树插入

```cpp
void insertBST(TreeNode*& root, int value) {
    if (root == NULL) {
        root = new TreeNode(value);
        return;
    }
    
    if (value < root->data) {
        insertBST3(root->left, value);
    } else if (value > root->data) {
        insertBST3(root->right, value);
    }
}
```



#### (使用二级指针完成)

```cpp
void insertBST(TreeNode** root, int value) {
    if (*root == NULL) {
        *root = (TreeNode*)malloc(sizeof(TreeNode));
        (*root)->data = value;
        (*root)->left = (*root)->right = NULL;
        return;
    }
    
    if (value < (*root)->data) {
        insertBST2(&((*root)->left), value);
    } else if (value > (*root)->data) {
        insertBST2(&((*root)->right), value);
    }
}

// 使用
int main() {
    TreeNode* root = NULL;
    insertBST2(&root, 10);
    insertBST2(&root, 5);
    insertBST2(&root, 15);
}
```



### 对比三种方法

| 方法           | 代码示例                                    | 优点             | 缺点         |
| :------------- | :------------------------------------------ | :--------------- | :----------- |
| **二级指针**   | `void insert(TreeNode** root, int val)`     | 标准C语言做法    | 语法复杂     |
| **指针引用**   | `void insert(TreeNode*& root, int val)`     | 语法简洁         | 仅限于C++    |

| **返回新指针** | `TreeNode* insert(TreeNode* root, int val)` | 函数式风格，清晰 | 调用者需赋值 |
